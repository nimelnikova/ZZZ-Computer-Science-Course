# Как сдавать задачи

## Навигация
1) [Локальная работа](#Локальная-работа)
2) [Что такое CI](#ci)
3) [Как сдать задачу](#Как-создать-PR?-Алгоритм.)

## `Локальная работа`
Первым делом скачайте себе данный репозиторий локально:
1. Делаем **fork** этого репозитория.
Копия этого репозитория появится в вашем аккаунте - это можно сделать в веб версии, нажав на кнопку
fork в верхней части проекта. 
2. Клонируем `ВАШ` fork себе на компьютер.
Прописать в терминале с установленным git:
```shell
git clone https://github.com/YourGitHubLogin/ZZZ-Computer-Science-Course.git

cd ZZZ-Computer-Science-Course
```
Где вместо `YourGitHubLogin` ваш логин на GitHub.   

3. Устанавливаем связь с оригинальным репозиторием.
Часто может быть, что репозиторий будет обновляться. Так как вы работаете с копием, необходимо подтягивать изменения из оригинального в копию. Для этого устоновите связь копии и оригинала:
```shell
git remote add upstream https://github.com/Maxsmile123/ZZZ-Computer-Science-Course
```

### `Следующие два пункта актуальны исключительно для задач на C/C++!`

4. Сборка проекта   

Перейдите в скачанный репозиторий и создайте папку `build` в корне репозитория, после чего соберите проект:
```shell
mkdir build
cd build
cmake ..
```
> Процесс может занять продолжительное время, наберитесь терпения.  
5. Сборка задачи

Для того, чтобы собрать вашу задачу, необходимо не покидая папки `build` прописать команду в формате:
```shell
make TASKVAR
```
После чего начнётся сборка, которая первоначально может занять продолжительное время.

Чтобы запустить тесты к задаче, пропишите:
```shell
./TASKVAR
```
### `Example`
Допустим, я работаю над задачей geometry, вариант 20. Тогда шаги будут следующими:
```shell
make geometry20
./geometry20
```

Это процедура необходима, чтобы проверить код на успешную компиляцию, отсутствие утечек памяти и UB. 

### `Запуск форматеров и линтеров для C/C++ кода`

В проекте предусмотрен кодстайл, который необходимо соблюдать. Для локального запуска линтеров и форматтеров, выполните следующие шаги:

0. Установите себе clang-format и clang-tidy
```shell
sudo apt-get install clang-format
sudo apt-get install clang-tidy
```

1. Скопируйте файлы .clang-format и .clang-tidy в папку `build`:
```shell
cp .clang-format build
cp .clang-tidy build
```
2. Запустите проверку, находясь в папке `build`:
```shell
../tools/run_linter.sh path
```
где `path` - путь к директории, которую необходимо проверить, в вашем случае это путь к папке с решаемым вариантом.

## `CI`

Данный процесс представляет автоматизацию деплоя кода в продакшн. 

В нашем случае это сборка кода под санитайзерами, которые проверяют код на ошибки работы с памятью и наличие UB, запуск форматтера, который проверит код на соответствие код стайлу, а также запуск тестов, если они предусмотрены.

- [Прочтите](./с_style.md) правила написания кода, которые будут проверяться в CI.

`Pull request(PR)` - это запрос стороннего пользователя на внесение изменений в проект. В нашем случае проект это репозиторий с лабораторными работами.

Перед добавлением вашего кода в общий репозиторий, ваши изменения проходят процедуру `code review`. Это дословно обзор вашего кода, проверка его на состоятельность, логичность и правильную структурность. По ходу ревью можно писать комментарии`(issues)` к автору изменений.

**Не отправляйте решение на проверку, если локально у вас вылазят ошибки - такие же ошибки вылезут и в CI**.

## `Какие решения не будут приняты?`
- Код, не прошедший проверки в CI
- Код, написанный не по [код стайлу](с_style.md)
- Неработающий код
- Код не своего варианта
- Изменение, удаление, добавление файлов, не предусмотренных заданием.


## `Как создать PR? Алгоритм.`
### 1. Создаём новую ветку
Под каждую лабу должна быть своя ветка. Название веток на ваш вкус.
Пример создания ветки и переключения на неё:
```shell
git checkout -b NameOfBranch
```
**ВАЖНО**  
Создавайте ветку исключительно от своей главной ветки! Иначе в PR могут добавиться файлы других задач! 

Для подтягивания изменений их оригинального репозитория, пропишите:
```shell
git checkout main
git fetch upstream
git merge upstream/main
git push origin main
```
### 2. Вносим изменения в код и делаем коммиты изменений
```shell
git add path // добавить файлы на Stage. Тут path - путь к директории/файлу, которые нужно добавить

git commit -m "lol" // Создать коммит на основе файлов в Stage. Commit message может быть любым
```
Чтобы узнать текущий статус изменений, пропишите:
```shell
git status
```
Чтобы посмотреть все коммиты текущей ветки, пропишите:
```shell
git log
```
Чтобы переключиться на другой коммит, пропишите:
```shell
git checkout commit_hash // Где commit_hash - это хэш коммита, на который хотите переключиться
```

Чтобы откатиться к предыдущей версии, пропишите:
```shell
git reset commit_hash // Все изменения от commit_hash до текущего будут лежать на Stage.

git reset --hard commit_hash // Все изменения от commit_hash до текущего безвозвратно удаляются.
```

### 3. Выполняем push на ваш удалённый репозиторий
Все ваши коммиты отправляем на удалённый репозиторий командой git push:
```shell
git push origin NameOfBranch
```
### 4. Заходим в веб версию, вкладка Pull Request
Нажимаем на создать, выбираем какую ветку хотим отправить и пишем описание PR: в нём должна
быть указана задача, которую вы выполнили.
### 5. Отправляем PR и ждём проверок c code review
### 6. В случае если в действующий PR нужно внести правки, повторите шаги с 2 - 5, исключая 4.
---

Если не нравится консольный git, то те же действия можно выполнить через кнопки в VS code. Как с ним работать описано [тут](https://code.visualstudio.com/docs/sourcecontrol/overview)
